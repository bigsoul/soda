#Если Сервер Тогда

#Область ОписаниеПеременных

Перем МодульПравил Экспорт;

Перем СоответствиеМетаданных Экспорт;
Перем СоответствиеРегистраций Экспорт;

#КонецОбласти

#Область ПрограммныйИнтерфейс

// ФУНКЦИИ: ТРЕБУЮЩИЕ БЕЗОПАСНОСТЬ ЦИКЛИЧЕСКИХ ССЫЛОК

Функция ЗаписатьСообщение(Data) Экспорт

	Попытка

		СтруктураОбъекта = СОД_Синхронизация.ЗначениеИзСтроки(Data);

		ИмяМетаданныхВИсточнике = СтруктураОбъекта.Ссылка.Группа + "_" + СтруктураОбъекта.Ссылка.Имя;
		ИмяМетаданныхВПриемнике = СоответствиеМетаданных[ИмяМетаданныхВИсточнике];

		Попытка

			НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);

			УстановитьБезопасныйРежим(Истина);

			Выполнить (ИмяМетаданныхВПриемнике + "_Запись(СтруктураОбъекта)");

			УстановитьБезопасныйРежим(Ложь);

			ЗафиксироватьТранзакцию();

			МодульПравил = Неопределено;

			Возврат "Успех";

		Исключение

			ОтменитьТранзакцию();

			Ошибка = ИнформацияОбОшибке();

			МодульПравил = Неопределено;

			Возврат "Неудача";

		КонецПопытки;

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецФункции

Функция ЗаполнитьОтправление(Ссылка, ОтправлениеСтруктура = Неопределено, Метод = Неопределено) Экспорт

	Попытка

		Если ОтправлениеСтруктура = Неопределено Тогда

			ОтправлениеСтруктура = Новый Структура;
			ОтправлениеСтруктура.Вставить("Маршрут", Неопределено);
			ОтправлениеСтруктура.Вставить("ДвоичныеДанные", Неопределено);
			ОтправлениеСтруктура.Вставить("ТекстовыеДанные", Неопределено);

		КонецЕсли;
		
		// получаем полную ссылку для определения выполняемого метода

		ПолнаяСсылка = ПолучитьПолнуюСсылку(Ссылка);

		ИмяМетаданныхВИсточнике = ПолнаяСсылка.Группа + "_" + ПолнаяСсылка.Имя;
		ПараметрыРегистрации 	= СоответствиеРегистраций[ИмяМетаданныхВИсточнике];

		// для объектов, которые не указаны как объекты требующие выгрузку поведение системы такое же, как для выключенных регистраций
		// т.е. правило регистрации выключено и отсутствует в соответствии регистраций - это одно и тоже
		// но для целей оптимизации производительности рекомендуется в подписке на событии использовать условия с проверкой на типы, либо отдельная подписка на каждый тип метаданных
		// так же, рекомендуется закомментировать следующее условие ниже, что бы контроль гарантированной регистрации или ошибки на отказ был полный

		Если ПараметрыРегистрации = Неопределено Тогда
			Возврат ОтправлениеСтруктура;
		КонецЕсли;
		
		// регистрация отключена для данного типа объекта метаданных

		Если Не ПараметрыРегистрации.Включен Тогда
			Возврат ОтправлениеСтруктура;
		КонецЕсли;

		ИмяМетодаРегистрации = ПараметрыРегистрации.ИмяМетодаРегистрации + "_Регистрация(Ссылка, Метод)";
		
		// если правила регистрации объекта для отправки позволяют, заполним структурой отправление

		УстановитьБезопасныйРежим(Истина);

		Если Вычислить(ИмяМетодаРегистрации) Тогда

			ИмяМетодаПравила = ПараметрыРегистрации.ИмяМетодаРегистрации + "_Чтение(Ссылка, Ложь, Метод)";

			ОтправлениеСтруктура.ТекстовыеДанные = Вычислить(ИмяМетодаПравила);

		КонецЕсли;

		УстановитьБезопасныйРежим(Ложь);

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	Возврат ОтправлениеСтруктура;

КонецФункции

// ПРОЦЕДУРЫ: ТРЕБУЮЩИЕ БЕЗОПАСНОСТЬ ЦИКЛИЧЕСКИХ ССЫЛОК

Процедура Инициализировать(ИсточникМодуля = Неопределено) Экспорт

	Попытка
		
		// подключаем модуль правил и создаем циклическую ссылку, про нее нельзя забывать !

		Если ИсточникМодуля = Неопределено Тогда

			МодульПравил = Неопределено;

			Возврат;

		КонецЕсли;
		
		//МодульПравил = ВнешниеОбработки.Создать(Правила, Ложь);

		Если ИсточникМодуля.Тип = Перечисления.СОД_ИсточникиОбработкиПравил.ИзФайла Тогда
			МодульПравил = ВнешниеОбработки.Создать(ИсточникМодуля.Источник, Ложь);
		ИначеЕсли ИсточникМодуля.Тип = Перечисления.СОД_ИсточникиОбработкиПравил.ИзКонфигурации Тогда
			МодульПравил = Обработки[ИсточникМодуля.Источник].Создать();
		КонецЕсли;

		МодульПравил.МодульСистемы = ЭтотОбъект;

		Для Каждого КлючЗначение Из МодульПравил.СоответствиеМетаданных Цикл

			СоответствиеМетаданных[КлючЗначение.Ключ] = КлючЗначение.Значение;

		КонецЦикла;

		Для Каждого КлючЗначение Из МодульПравил.СоответствиеРегистраций Цикл

			СоответствиеРегистраций[КлючЗначение.Ключ] = КлючЗначение.Значение;

		КонецЦикла;
		
		// легитимное создание циклической ссылки

		Возврат;

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецПроцедуры

Процедура Деинициализировать() Экспорт
	
	// уничтожение всех свойств состояния модуля
	// далее, использование возможно только через повторную инициализацию

	Попытка

		МодульПравил 			= Неопределено; // уничтожим циклическую ссылку
		СоответствиеМетаданных 	= Неопределено; // уничтожим соответствия метаданных

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено; // контроль циклической ссылки

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено; // контроль циклической ссылки		

КонецПроцедуры

Процедура РегистрацииТранспорт() Экспорт

	Попытка
		
		// получим все регистрации в порядке создания для дальнейшей обработки
		
		// ПАРАМЕТРЫ ВЫБОРКИ
		// необходимо отправить все исходящие регистрации в статусе отправлено = ложь

		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ
					   |	СОД_Узлы.Ссылка КАК Ссылка
					   |ИЗ
					   |	ПланОбмена.СОД_Узлы КАК СОД_Узлы
					   |ГДЕ
					   |	СОД_Узлы.Отключен = ЛОЖЬ
					   |	И СОД_Узлы.ПротоколДоставкиОтправлений = ЗНАЧЕНИЕ(Перечисление.СОД_ПротоколыДоставкиОтправлений.AMQP)
					   |;
					   |
					   |////////////////////////////////////////////////////////////////////////////////
					   |ВЫБРАТЬ
					   |	СОД_Регистрации.Ссылка КАК Ссылка,
					   |	СОД_Регистрации.Узел КАК Узел
					   |ИЗ
					   |	Справочник.СОД_Регистрации КАК СОД_Регистрации
					   |ГДЕ
					   |	СОД_Регистрации.Направление = ЗНАЧЕНИЕ(Перечисление.СОД_НаправлениеРегистрации.Исходящее)
					   |	И СОД_Регистрации.Отправлено = ЛОЖЬ
					   |
					   |УПОРЯДОЧИТЬ ПО
					   |	СОД_Регистрации.Код";

		РезультатПакета = Запрос.ВыполнитьПакет();

		УзлыКОпросу	    	 = РезультатПакета[0].Выгрузить().ВыгрузитьКолонку("Ссылка");
		РегистрацииКОтправке = РезультатПакета[1].Выгрузить();
		
		// разделим регистрации по узлам с сохранением порядка

		ДанныеПоПолучателям = Новый Массив;

		Для Каждого СтрокаЗапроса Из РегистрацииКОтправке Цикл

			ДанныеПолучателя = Неопределено;

			Для Каждого Данные Из ДанныеПоПолучателям Цикл

				Если Данные.Узел = СтрокаЗапроса.Узел Тогда

					ДанныеПолучателя = Данные;

					Прервать;

				КонецЕсли;

			КонецЦикла;

			Если ДанныеПолучателя = Неопределено Тогда

				ДанныеПолучателя = Новый Структура;
				ДанныеПолучателя.Вставить("Узел", СтрокаЗапроса.Узел);
				ДанныеПолучателя.Вставить("Метод", "Транспорт");
				ДанныеПолучателя.Вставить("Строки", Новый Массив);

				ДанныеПоПолучателям.Добавить(ДанныеПолучателя);

			КонецЕсли;

			ДанныеПолучателя.Строки.Добавить(СтрокаЗапроса.Ссылка);

		КонецЦикла;  
		
		// добавим узлы, на которые нет регистраций
		// добавляемые узлы не являются отключенными и настроены на протокол AMQP
		// таким образом для этих узлов будет делаться попытка получить сообщения

		Для Каждого Узел Из УзлыКОпросу Цикл

			ДанныеПолучателя = Неопределено;

			Для Каждого Данные Из ДанныеПоПолучателям Цикл

				Если Данные.Узел = Узел Тогда

					Прервать;

				КонецЕсли;

			КонецЦикла;

			Если ДанныеПолучателя = Неопределено Тогда

				ДанныеПолучателя = Новый Структура;
				ДанныеПолучателя.Вставить("Узел", Узел);
				ДанныеПолучателя.Вставить("Метод", "Транспорт");
				ДанныеПолучателя.Вставить("Строки", Новый Массив);

				ДанныеПоПолучателям.Добавить(ДанныеПолучателя);

			КонецЕсли;

		КонецЦикла; 
		
		// отправим и получим сообщения

		Для Каждого ДанныеПолучателя Из ДанныеПоПолучателям Цикл

			СОД_Синхронизация.РегистрацииТранспортЗапуститьПотоки(ДанныеПолучателя);

		КонецЦикла;

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецПроцедуры

Процедура РегистрацииТранспортПоток_Чтение(ДанныеПолучателя) Экспорт

	Попытка
		
		// отдельно для каждого получателя отошлем регистрации

		Если ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений
			= Перечисления.СОД_ПротоколыДоставкиОтправлений.WEBСервис Тогда
			Прокси = СОД_Синхронизация.ПолучитьWSПрокси(ДанныеПолучателя.Узел);
		КонецЕсли;

		Для Каждого Регистрация Из ДанныеПолучателя.Строки Цикл

			РегистрацияОбъект = Регистрация.ПолучитьОбъект();

			Попытка

				РегистрацияОбъект.Заблокировать();

			Исключение

				МодульПравил = Неопределено;

				Возврат;

			КонецПопытки;

			СтруктураРегистрации = Справочник_СОД_Регистрации_Чтение(Регистрация, , ДанныеПолучателя.Метод);
			СтрокаРегистрации = СОД_Синхронизация.ЗначениеВСтроку(СтруктураРегистрации, Регистрация.ФорматСообщения);

			Если ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений
				= Перечисления.СОД_ПротоколыДоставкиОтправлений.WEBСервис Тогда
				СтрокаВозврата = Прокси.Run(СтрокаРегистрации);
			ИначеЕсли ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений
				= Перечисления.СОД_ПротоколыДоставкиОтправлений.HTTPСервис Тогда
				СтрокаВозврата = СОД_Синхронизация.ВыполнитьHSЗапросRun(ДанныеПолучателя.Узел, СтрокаРегистрации);
			ИначеЕсли ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений
				= Перечисления.СОД_ПротоколыДоставкиОтправлений.AMQP Тогда

				Клиент = СОД_Синхронизация.ПолучитьAMQPКлиентHTTP(ДанныеПолучателя.Узел);

				СОД_Синхронизация.ОбновитьМаршрутAMQPHTTP(Клиент, ДанныеПолучателя.Узел,
					Перечисления.СОД_НаправлениеРегистрации.Исходящее);

				СтрокаВозврата = СОД_Синхронизация.ТранспортAMQPИсходящееHTTP(Клиент, ДанныеПолучателя.Узел,
					СтрокаРегистрации);

				Клиент = Неопределено;

			КонецЕсли;

			Если СтрокаВозврата = "Успех" Тогда

				РегистрацияОбъект.Отправлено = Истина;

				Если РегистрацияОбъект.ИсходящееПодтверждение И РегистрацияОбъект.ВходящееПодтверждение Тогда
					РегистрацияОбъект.ОбработкаПодтверждена = Истина;
				КонецЕсли;

				РегистрацияОбъект.Записать();

			КонецЕсли;

		КонецЦикла;

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецПроцедуры

Процедура РегистрацииТранспортПоток_Запись(ДанныеПолучателя) Экспорт

	Если ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений <> Перечисления.СОД_ПротоколыДоставкиОтправлений.AMQP Тогда
		Возврат;
	КонецЕсли;

	Узел = ДанныеПолучателя.Узел;

	ИмяОчереди = Узел.AMQPВходящееИмяТочкиОбмена + "." + Узел.AMQPВходящееИмяОчередиТранспорт;

	СОД_Обмен = СОД_Синхронизация.ПолучитьМодульСистемы();
	СОД_Обмен.Инициализировать(СОД_МаршрутизацияВызовСервераПовтИсп.ОбработкаОтладкиПравил());

	Попытка

		Клиент = СОД_Синхронизация.ПолучитьAMQPКлиентHTTP(Узел);

		Прочитано = Истина;

		Пока Прочитано Цикл 
			
			// + начало получения сообщения

			HTTPЗапрос = Новый HTTPЗапрос;

			HTTPЗапрос.АдресРесурса = "/api/queues/" + Узел.AMQPВходящееВиртуальныйХост + "/" + ИмяОчереди + "/get";
			HTTPЗапрос.Заголовки.Вставить("Content-type", "application/json; charset=utf-8");

			Режим = ?(Ложь, "ack_requeue_false", "ack_requeue_true");

			HTTPЗапрос.УстановитьТелоИзСтроки("{""count"":1,""ackmode"":""" + Режим
				+ """,""encoding"":""auto"",""truncate"":50000}");

			HTTPОтвет = Клиент.ОтправитьДляОбработки(HTTPЗапрос);

			Если HTTPОтвет.КодСостояния = 404 Тогда
				Прервать;
			ИначеЕсли HTTPОтвет.КодСостояния <> 200 Тогда
				ВызватьИсключение "Не удалось получить сообщение с сервера, код состояния: " + HTTPОтвет.КодСостояния;
			КонецЕсли;

			Сообщение = HTTPОтвет.ПолучитьТелоКакСтроку();

			Прочитано = Сообщение <> "[]";
			
			// - конец получения сообщения  

			Если Не Прочитано Тогда
				Прервать;
			КонецЕсли;

			СообщениеAMQP = СОД_Синхронизация.ЗначениеИзСтроки(Сообщение, Перечисления.СОД_ФорматыСообщений.JSON)[0];

			СОД_Синхронизация.ДобавитьПротоколОбменаРегистрациями(Истина, СообщениеAMQP.payload);

			НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);

			СОД_Обмен.ЗаписатьСообщение(СообщениеAMQP.payload);

			ЗафиксироватьТранзакцию();
			
			// + начало получения сообщения

			HTTPЗапрос = Новый HTTPЗапрос;

			HTTPЗапрос.АдресРесурса = "/api/queues/" + Узел.AMQPВходящееВиртуальныйХост + "/" + ИмяОчереди + "/get";
			HTTPЗапрос.Заголовки.Вставить("Content-type", "application/json; charset=utf-8");

			Режим = ?(Истина, "ack_requeue_false", "ack_requeue_true");

			HTTPЗапрос.УстановитьТелоИзСтроки("{""count"":1,""ackmode"":""" + Режим
				+ """,""encoding"":""auto"",""truncate"":50000}");

			HTTPОтвет = Клиент.ОтправитьДляОбработки(HTTPЗапрос);

			Если HTTPОтвет.КодСостояния = 404 Тогда
				Прервать;
			ИначеЕсли HTTPОтвет.КодСостояния <> 200 Тогда
				ВызватьИсключение "Не удалось получить сообщение с сервера, код состояния: " + HTTPОтвет.КодСостояния;
			КонецЕсли;

			Сообщение = HTTPОтвет.ПолучитьТелоКакСтроку();

			Прочитано = Сообщение <> "[]";
			
			// - конец получения сообщения

		КонецЦикла;

		Клиент = Неопределено;

		СОД_Обмен.МодульПравил = Неопределено;
		СОД_Обмен = Неопределено;

	Исключение

		СОД_Обмен.МодульПравил = Неопределено;
		СОД_Обмен = Неопределено;

		Ошибка = ОписаниеОшибки();

		ВызватьИсключение Ошибка;

	КонецПопытки;

КонецПроцедуры

Процедура РегистрацииТранспортПодтверждение() Экспорт

	Попытка
		
		// получим все регистрации в порядке создания для дальнейшей обработки
		
		// ПАРАМЕТРЫ ВЫБОРКИ
		// необходимо подтвердить все входящие и исходящие регистрации в статусе обработано = ложь, которые небыли подтверждены рание (ИсходящееПодтверждение = ложь)

		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ
					   |	СОД_Узлы.Ссылка КАК Ссылка
					   |ИЗ
					   |	ПланОбмена.СОД_Узлы КАК СОД_Узлы
					   |ГДЕ
					   |	СОД_Узлы.Отключен = ЛОЖЬ
					   |	И СОД_Узлы.ПротоколДоставкиОтправлений = ЗНАЧЕНИЕ(Перечисление.СОД_ПротоколыДоставкиОтправлений.AMQP)
					   |;
					   |
					   |////////////////////////////////////////////////////////////////////////////////
					   |ВЫБРАТЬ
					   |	СОД_Регистрации.Ссылка КАК Ссылка,
					   |	СОД_Регистрации.Узел КАК Узел
					   |ИЗ
					   |	Справочник.СОД_Регистрации КАК СОД_Регистрации
					   |ГДЕ
					   |	СОД_Регистрации.Обработано = ИСТИНА
					   |	И СОД_Регистрации.ИсходящееПодтверждение = ЛОЖЬ
					   |
					   |УПОРЯДОЧИТЬ ПО
					   |	СОД_Регистрации.Код";

		РезультатПакета = Запрос.ВыполнитьПакет();

		УзлыКОпросу	    	 = РезультатПакета[0].Выгрузить().ВыгрузитьКолонку("Ссылка");
		РегистрацииКОтправке = РезультатПакета[1].Выгрузить();
		
		// разделим регистрации по узлам с сохранением порядка

		ДанныеПоПолучателям = Новый Массив;

		Для Каждого СтрокаЗапроса Из РегистрацииКОтправке Цикл

			ДанныеПолучателя = Неопределено;

			Для Каждого Данные Из ДанныеПоПолучателям Цикл

				Если Данные.Узел = СтрокаЗапроса.Узел Тогда

					ДанныеПолучателя = Данные;

					Прервать;

				КонецЕсли;

			КонецЦикла;

			Если ДанныеПолучателя = Неопределено Тогда

				ДанныеПолучателя = Новый Структура;
				ДанныеПолучателя.Вставить("Узел", СтрокаЗапроса.Узел);
				ДанныеПолучателя.Вставить("Метод", "ТранспортПодтверждение");
				ДанныеПолучателя.Вставить("Строки", Новый Массив);

				ДанныеПоПолучателям.Добавить(ДанныеПолучателя);

			КонецЕсли;

			ДанныеПолучателя.Строки.Добавить(СтрокаЗапроса.Ссылка);

		КонецЦикла;
		
		// добавим узлы, на которые нет регистраций
		// добавляемые узлы не являются отключенными и настроены на протокол AMQP
		// таким образом для этих узлов будет делаться попытка получить сообщения

		Для Каждого Узел Из УзлыКОпросу Цикл

			ДанныеПолучателя = Неопределено;

			Для Каждого Данные Из ДанныеПоПолучателям Цикл

				Если Данные.Узел = Узел Тогда

					Прервать;

				КонецЕсли;

			КонецЦикла;

			Если ДанныеПолучателя = Неопределено Тогда

				ДанныеПолучателя = Новый Структура;
				ДанныеПолучателя.Вставить("Узел", Узел);
				ДанныеПолучателя.Вставить("Метод", "ТранспортПодтверждение");
				ДанныеПолучателя.Вставить("Строки", Новый Массив);

				ДанныеПоПолучателям.Добавить(ДанныеПолучателя);

			КонецЕсли;

		КонецЦикла;
		
		// отправим и получим сообщения

		Для Каждого ДанныеПолучателя Из ДанныеПоПолучателям Цикл

			СОД_Синхронизация.РегистрацииТранспортПодтверждениеЗапуститьПотоки(ДанныеПолучателя);

		КонецЦикла;

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецПроцедуры

Процедура РегистрацииТранспортПодтверждениеПоток_Чтение(ДанныеПолучателя) Экспорт

	Клиент = Неопределено;

	Попытка
		
		// отдельно для каждого получателя отошлем регистрации

		СОД_Синхронизация.ПолучитьМодульСистемы();

		Если ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений
			= Перечисления.СОД_ПротоколыДоставкиОтправлений.WEBСервис Тогда
			Прокси = СОД_Синхронизация.ПолучитьWSПрокси(ДанныеПолучателя.Узел);
		КонецЕсли;

		Для Каждого Регистрация Из ДанныеПолучателя.Строки Цикл

			РегистрацияОбъект = Регистрация.ПолучитьОбъект();

			Попытка

				РегистрацияОбъект.Заблокировать();

			Исключение

				МодульПравил = Неопределено;

				Возврат;

			КонецПопытки;

			СтруктураРегистрации = Справочник_СОД_Регистрации_Чтение(Регистрация, , ДанныеПолучателя.Метод);
			СтрокаРегистрации = СОД_Синхронизация.ЗначениеВСтроку(СтруктураРегистрации, Регистрация.ФорматСообщения);

			Если ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений
				= Перечисления.СОД_ПротоколыДоставкиОтправлений.WEBСервис Тогда
				СтрокаВозврата = Прокси.Run(СтрокаРегистрации);
			ИначеЕсли ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений
				= Перечисления.СОД_ПротоколыДоставкиОтправлений.HTTPСервис Тогда
				СтрокаВозврата = СОД_Синхронизация.ВыполнитьHSЗапросRun(ДанныеПолучателя.Узел, СтрокаРегистрации);
			ИначеЕсли ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений
				= Перечисления.СОД_ПротоколыДоставкиОтправлений.AMQP Тогда

				Клиент = СОД_Синхронизация.ПолучитьAMQPКлиентHTTP(ДанныеПолучателя.Узел);

				СОД_Синхронизация.ОбновитьМаршрутAMQPПодтверждениеHTTP(Клиент, ДанныеПолучателя.Узел,
					Перечисления.СОД_НаправлениеРегистрации.Исходящее);

				СтрокаВозврата = СОД_Синхронизация.ТранспортПодтверждениеAMQPИсходящееHTTP(Клиент,
					ДанныеПолучателя.Узел, СтрокаРегистрации);

				Клиент = Неопределено;

			КонецЕсли;

			Если СтрокаВозврата = "Успех" Тогда

				РегистрацияОбъект.ИсходящееПодтверждение = Истина;

				Если РегистрацияОбъект.ИсходящееПодтверждение И РегистрацияОбъект.ВходящееПодтверждение Тогда
					РегистрацияОбъект.ОбработкаПодтверждена = Истина;
				КонецЕсли;

				РегистрацияОбъект.Записать();

			КонецЕсли;

		КонецЦикла;

	Исключение

		Ошибка = ОписаниеОшибки();

		Клиент = Неопределено;
		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецПроцедуры

Процедура РегистрацииТранспортПодтверждениеПоток_Запись(ДанныеПолучателя) Экспорт

	Если ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений <> Перечисления.СОД_ПротоколыДоставкиОтправлений.AMQP Тогда
		Возврат;
	КонецЕсли;

	Узел = ДанныеПолучателя.Узел;

	ИмяОчереди = Узел.AMQPВходящееИмяТочкиОбмена + "." + Узел.AMQPВходящееИмяОчередиТранспортПодтверждение;

	СОД_Обмен = СОД_Синхронизация.ПолучитьМодульСистемы();
	СОД_Обмен.Инициализировать(СОД_МаршрутизацияВызовСервераПовтИсп.ОбработкаОтладкиПравил());

	Попытка

		Клиент = СОД_Синхронизация.ПолучитьAMQPКлиентHTTP(Узел);

		Прочитано = Истина;

		Пока Прочитано Цикл 
			
			// + начало получения сообщения

			HTTPЗапрос = Новый HTTPЗапрос;

			HTTPЗапрос.АдресРесурса = "/api/queues/" + Узел.AMQPВходящееВиртуальныйХост + "/" + ИмяОчереди + "/get";
			HTTPЗапрос.Заголовки.Вставить("Content-type", "application/json; charset=utf-8");

			Режим = ?(Ложь, "ack_requeue_false", "ack_requeue_true");

			HTTPЗапрос.УстановитьТелоИзСтроки("{""count"":1,""ackmode"":""" + Режим
				+ """,""encoding"":""auto"",""truncate"":50000}");

			HTTPОтвет = Клиент.ОтправитьДляОбработки(HTTPЗапрос);

			Если HTTPОтвет.КодСостояния = 404 Тогда
				Прервать;
			ИначеЕсли HTTPОтвет.КодСостояния <> 200 Тогда
				ВызватьИсключение "Не удалось получить сообщение с сервера, код состояния: " + HTTPОтвет.КодСостояния;
			КонецЕсли;

			Сообщение = HTTPОтвет.ПолучитьТелоКакСтроку();

			Прочитано = Сообщение <> "[]";
			
			// - конец получения сообщения  

			Если Не Прочитано Тогда
				Прервать;
			КонецЕсли;

			СообщениеAMQP = СОД_Синхронизация.ЗначениеИзСтроки(Сообщение, Перечисления.СОД_ФорматыСообщений.JSON)[0];

			СОД_Синхронизация.ДобавитьПротоколОбменаРегистрациями(Истина, СообщениеAMQP.payload);

			НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);

			СОД_Обмен.ЗаписатьСообщение(СообщениеAMQP.payload);

			ЗафиксироватьТранзакцию();
			
			// + начало получения сообщения

			HTTPЗапрос = Новый HTTPЗапрос;

			HTTPЗапрос.АдресРесурса = "/api/queues/" + Узел.AMQPВходящееВиртуальныйХост + "/" + ИмяОчереди + "/get";
			HTTPЗапрос.Заголовки.Вставить("Content-type", "application/json; charset=utf-8");

			Режим = ?(Истина, "ack_requeue_false", "ack_requeue_true");

			HTTPЗапрос.УстановитьТелоИзСтроки("{""count"":1,""ackmode"":""" + Режим
				+ """,""encoding"":""auto"",""truncate"":50000}");

			HTTPОтвет = Клиент.ОтправитьДляОбработки(HTTPЗапрос);

			Если HTTPОтвет.КодСостояния = 404 Тогда
				Прервать;
			ИначеЕсли HTTPОтвет.КодСостояния <> 200 Тогда
				ВызватьИсключение "Не удалось получить сообщение с сервера, код состояния: " + HTTPОтвет.КодСостояния;
			КонецЕсли;

			Сообщение = HTTPОтвет.ПолучитьТелоКакСтроку();

			Прочитано = Сообщение <> "[]";
			
			// - конец получения сообщения

		КонецЦикла;

		Клиент = Неопределено;

		СОД_Обмен.МодульПравил = Неопределено;
		СОД_Обмен = Неопределено;

	Исключение

		СОД_Обмен.МодульПравил = Неопределено;
		СОД_Обмен = Неопределено;

		Ошибка = ОписаниеОшибки();

		ВызватьИсключение Ошибка;

	КонецПопытки;

КонецПроцедуры

Процедура РегистрацииТочкаАктуальности() Экспорт 
	
	// точка актуальности - временная граница по которую (включительно) были отправленны регистрации в узел
	// в конечном узле точка актуальности используется для обработки регистраций, так как гарантирует, что по данную дату-время в узле есть полный набор регистраций из двух баз
	// при обработке выполняется анализ и применяется последняя версия (если она входящая)

	Попытка

		ПолноеИмяФайлаЛога = СОД_Логирование.СоздатьНовыйФайл();

		СОД_Логирование.ДобавитьСтроку(ПолноеИмяФайлаЛога, " Начало операции");  
	
		// получим два диапазона значение дат регистрации
		// первый диапазон - минимальная и максимальная дата регистраций отправленных
		// второй диапазон - минимальная и максимальная дата регистраций еще ожидающие отправки

		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ТекущаяДата", УниверсальноеВремя( ТекущаяДатаСеанса()));
		Запрос.Текст = "ВЫБРАТЬ
					   |	СОД_Узлы.Ссылка КАК Узел
					   |ПОМЕСТИТЬ Узлы
					   |ИЗ
					   |	ПланОбмена.СОД_Узлы КАК СОД_Узлы
					   |ГДЕ
					   |	СОД_Узлы.Отключен = ЛОЖЬ
					   |
					   |ИНДЕКСИРОВАТЬ ПО
					   |	Узел
					   |;
					   |
					   |////////////////////////////////////////////////////////////////////////////////
					   |ВЫБРАТЬ
					   |	Узлы.Узел
					   |ИЗ
					   |	Узлы КАК Узлы
					   |;
					   |
					   |////////////////////////////////////////////////////////////////////////////////
					   |ВЫБРАТЬ
					   |	Узлы.Узел КАК Узел,
					   |	МИНИМУМ(СОД_Регистрации.ДатаРегистрации) КАК ДатаРегистрацииМин,
					   |	МАКСИМУМ(СОД_Регистрации.ДатаРегистрации) КАК ДатаРегистрацииМакс
					   |ИЗ
					   |	Узлы КАК Узлы
					   |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.СОД_Регистрации КАК СОД_Регистрации
					   |		ПО Узлы.Узел = СОД_Регистрации.Узел
					   |ГДЕ
					   |	СОД_Регистрации.Отправлено = ИСТИНА
					   |	И СОД_Регистрации.Направление = ЗНАЧЕНИЕ(Перечисление.СОД_НаправлениеРегистрации.Исходящее)
					   |	И СОД_Регистрации.ДатаРегистрации <= &ТекущаяДата
					   |
					   |СГРУППИРОВАТЬ ПО
					   |	Узлы.Узел
					   |;
					   |
					   |////////////////////////////////////////////////////////////////////////////////
					   |ВЫБРАТЬ
					   |	Узлы.Узел КАК Узел,
					   |	МИНИМУМ(СОД_Регистрации.ДатаРегистрации) КАК ДатаРегистрацииМин,
					   |	МАКСИМУМ(СОД_Регистрации.ДатаРегистрации) КАК ДатаРегистрацииМакс
					   |ИЗ
					   |	Узлы КАК Узлы
					   |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.СОД_Регистрации КАК СОД_Регистрации
					   |		ПО Узлы.Узел = СОД_Регистрации.Узел
					   |ГДЕ
					   |	СОД_Регистрации.Отправлено = ЛОЖЬ
					   |	И СОД_Регистрации.Направление = ЗНАЧЕНИЕ(Перечисление.СОД_НаправлениеРегистрации.Исходящее)
					   |	И СОД_Регистрации.ДатаРегистрации <= &ТекущаяДата
					   |
					   |СГРУППИРОВАТЬ ПО
					   |	Узлы.Узел";

		РезультатПакета = Запрос.ВыполнитьПакет();

		СписокУзлов 					= РезультатПакета[1].Выгрузить().ВыгрузитьКолонку("Узел");
		СписокРегистрацийОтправленных 	= РезультатПакета[2].Выгрузить();
		СписокРегистрацийВОжидании 		= РезультатПакета[3].Выгрузить();

		РезультатПакета = Неопределено; // освободим память

		ПланТА = Новый Соответствие;

		Для Каждого Узел Из СписокУзлов Цикл

			РегистрацииОтправленные = СписокРегистрацийОтправленных.НайтиСтроки(Новый Структура("Узел", Узел));
			РегистрацииВОжидании    = СписокРегистрацийВОжидании.НайтиСтроки(Новый Структура("Узел", Узел));
			
			// получим 4-е переменные, которые содержат даты для двух диапазонов

			Если РегистрацииОтправленные.Количество() Тогда
				ДатаОтправленныхМин 	= РегистрацииОтправленные[0].ДатаРегистрацииМин;
				ДатаОтправленныхМакс 	= РегистрацииОтправленные[0].ДатаРегистрацииМакс;
			Иначе
				ДатаОтправленныхМин 	= Неопределено;
				ДатаОтправленныхМакс 	= Неопределено;
			КонецЕсли;

			Если РегистрацииВОжидании.Количество() Тогда
				ВОжиданииМин 			= РегистрацииВОжидании[0].ДатаРегистрацииМин;
				ВОжиданииМакс 			= РегистрацииВОжидании[0].ДатаРегистрацииМакс;
			Иначе
				ВОжиданииМин 			= Неопределено;
				ВОжиданииМакс 			= Неопределено;
			КонецЕсли;

			Если ЗначениеЗаполнено(ДатаОтправленныхМин) И ЗначениеЗаполнено(ДатаОтправленныхМакс) И ЗначениеЗаполнено(
				ВОжиданииМин) И ЗначениеЗаполнено(ВОжиданииМакс) Тогда
				
				// если оба диапазона заполнены, значит необходимо проверить
				// возможно диапазоны пересикаются или диапазон ожидающих меньше диапазона отправленных, если так, то точка актуальности будет самый маленький не отправленный регистрация (-1 секунад)
				// если диапазоны не пересикаются и диапазон ожидающих не меньше диапазона отправленных, проверим, может быть диапазон ожидаемых больше диапазона отправленных
				// если диапазон ожидающих больше диапазона отправленных, точкой актуальности будет максимальная дата отправленных
				// в противном случае - текущая дата

				Если ВОжиданииМин <= ДатаОтправленныхМакс Тогда
					ТочкаАктуальности = ВОжиданииМин - 1;
				ИначеЕсли ВОжиданииМакс <= ДатаОтправленныхМакс Тогда
					ТочкаАктуальности = ВОжиданииМакс - 1;
				ИначеЕсли ВОжиданииМин > ДатаОтправленныхМакс Тогда
					ТочкаАктуальности = ДатаОтправленныхМакс;
				ИначеЕсли ВОжиданииМакс > ДатаОтправленныхМакс Тогда
					ТочкаАктуальности = ДатаОтправленныхМакс;
				Иначе
					ТочкаАктуальности = УниверсальноеВремя( ТекущаяДатаСеанса() - 1);
				КонецЕсли;

			ИначеЕсли ЗначениеЗаполнено(ДатаОтправленныхМин) И ЗначениеЗаполнено(ДатаОтправленныхМакс)
				И Не ЗначениеЗаполнено(ВОжиданииМин) И Не ЗначениеЗаполнено(ВОжиданииМакс) Тогда
				
				// в базе все регистрации отправленные, поэтому точка актуальности текущая дата (-1 секунда)

				ТочкаАктуальности = УниверсальноеВремя( ТекущаяДатаСеанса() - 1);

			ИначеЕсли Не ЗначениеЗаполнено(ДатаОтправленныхМин) И Не ЗначениеЗаполнено(ДатаОтправленныхМакс)
				И ЗначениеЗаполнено(ВОжиданииМин) И ЗначениеЗаполнено(ВОжиданииМакс) Тогда
				
				// в базе все регистрации не отправленные, поэтому точка актуальности самая маленькая дата диапазона ожидаемых (-1 секунда)

				ТочкаАктуальности = ВОжиданииМин - 1;

			Иначе
				
				// в базе вообще нет регистраций для отправки, дата актуальности текущая (-1 секунда)

				ТочкаАктуальности = УниверсальноеВремя( ТекущаяДатаСеанса() - 1);

			КонецЕсли;

			ПланТА.Вставить(Узел, ТочкаАктуальности);

		КонецЦикла;
		
		// отправим точки актуальности

		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Узлы", СписокУзлов);
		Запрос.Текст = "ВЫБРАТЬ
					   |	СОД_ТочкиАктуальностиИсходящие.Узел КАК Узел
					   |ИЗ
					   |	РегистрСведений.СОД_ТочкиАктуальностиИсходящие КАК СОД_ТочкиАктуальностиИсходящие
					   |ГДЕ
					   |	СОД_ТочкиАктуальностиИсходящие.Узел В(&Узлы)
					   |
					   |УПОРЯДОЧИТЬ ПО
					   |	СОД_ТочкиАктуальностиИсходящие.Узел.Приоритет УБЫВ";

		ТочкиАктуальности = Запрос.Выполнить().Выгрузить();
		
		// если узла нет в списке ТА - добавим его

		Для Каждого Пара Из ПланТА Цикл

			НайденыеСтроки = ТочкиАктуальности.НайтиСтроки(Новый Структура("Узел", Пара.Ключ));

			Если Не НайденыеСтроки.Количество() Тогда
				НоваяСтрока = ТочкиАктуальности.Добавить();
				НоваяСтрока.Узел = Пара.Ключ;
			КонецЕсли;

		КонецЦикла;

		СОД_Логирование.ДобавитьСтроку(ПолноеИмяФайлаЛога, " Узлов к обработке: [" + ПланТА.Количество() + "]");
		СОД_Логирование.ДобавитьСтроку(ПолноеИмяФайлаЛога, " Запуск цикла отправлений");

		Для Каждого Строка Из ТочкиАктуальности Цикл

			Узел 			  = Строка.Узел;
			ТочкаАктуальности = ПланТА[Узел];

			ДанныеПолучателя = Новый Структура;
			ДанныеПолучателя.Вставить("Узел", Узел);
			ДанныеПолучателя.Вставить("ТочкаАктуальности", ТочкаАктуальности);
			ДанныеПолучателя.Вставить("ПолноеИмяФайлаЛога", ПолноеИмяФайлаЛога);
			
			//РегистрацииТочкаАктуальности_Запись(ДанныеПолучателя);
			РегистрацииТочкаАктуальности_Чтение(ДанныеПолучателя);

		КонецЦикла;

		СОД_Логирование.ДобавитьСтроку(ПолноеИмяФайлаЛога, " Конец операции");

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецПроцедуры

Процедура РегистрацииТочкаАктуальности_Чтение(ДанныеПолучателя) Экспорт

	Попытка

		Узел 			   = ДанныеПолучателя.Узел;
		ТочкаАктуальности  = ДанныеПолучателя.ТочкаАктуальности;
		ПолноеИмяФайлаЛога = ДанныеПолучателя.ПолноеИмяФайлаЛога;

		СОД_Логирование.ДобавитьСтроку(ПолноеИмяФайлаЛога, " " + Узел + " начало");

		НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);

		БлокировкаДанных = Новый БлокировкаДанных;

		ЭлементБлокировки = БлокировкаДанных.Добавить("РегистрСведений.СОД_ТочкиАктуальностиИсходящие");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		ЭлементБлокировки.УстановитьЗначение("Узел", Узел);

		БлокировкаДанных.Заблокировать();

		Набор = РегистрыСведений.СОД_ТочкиАктуальностиИсходящие.СоздатьНаборЗаписей();
		Набор.Отбор.Узел.Установить(Узел);

		Запись = Набор.Добавить();

		Запись.Узел = Узел;
		Запись.ТочкаАктуальности = ТочкаАктуальности;

		Набор.Записать();

		ЗафиксироватьТранзакцию();

		Клиент = Неопределено;

		СтруктураРегистрации = РегистрСведений_СОД_ТочкиАктуальностиИсходящие_Чтение(Набор);

		Попытка

			СтрокаРегистрации = СОД_Синхронизация.ЗначениеВСтроку(СтруктураРегистрации, Узел.ФорматСообщения);

			Если Узел.ПротоколДоставкиОтправлений = Перечисления.СОД_ПротоколыДоставкиОтправлений.WEBСервис Тогда

				Прокси = СОД_Синхронизация.ПолучитьWSПрокси(Узел);
				СтрокаВозврата = Прокси.Run(СтрокаРегистрации);

			ИначеЕсли Узел.ПротоколДоставкиОтправлений = Перечисления.СОД_ПротоколыДоставкиОтправлений.HTTPСервис Тогда

				СтрокаВозврата = СОД_Синхронизация.ВыполнитьHSЗапросRun(Узел, СтрокаРегистрации);

			ИначеЕсли Узел.ПротоколДоставкиОтправлений = Перечисления.СОД_ПротоколыДоставкиОтправлений.AMQP Тогда

				Клиент = СОД_Синхронизация.ПолучитьAMQPКлиентHTTP(Узел);

				СОД_Синхронизация.ОбновитьМаршрутAMQPТочкаАктуальностиHTTP(Клиент, Узел,
					Перечисления.СОД_НаправлениеРегистрации.Исходящее);

				СтрокаВозврата = СОД_Синхронизация.ТочкаАктуальностиAMQPИсходящееHTTP(Клиент, Узел, СтрокаРегистрации);

				Клиент = Неопределено;

			КонецЕсли;

			Если СтрокаВозврата = "Успех" Тогда

				НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);

				БлокировкаДанных = Новый БлокировкаДанных;

				ЭлементБлокировки = БлокировкаДанных.Добавить("РегистрСведений.СОД_ТочкиАктуальностиДоставленные");
				ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
				ЭлементБлокировки.УстановитьЗначение("Узел", Узел);

				БлокировкаДанных.Заблокировать();

				Набор = РегистрыСведений.СОД_ТочкиАктуальностиДоставленные.СоздатьНаборЗаписей();
				Набор.Отбор.Узел.Установить(Узел);

				Запись = Набор.Добавить();

				Запись.Узел = Узел;
				Запись.ТочкаАктуальности = ТочкаАктуальности;

				Набор.Записать();

				ЗафиксироватьТранзакцию();

			КонецЕсли;

			СОД_Логирование.ДобавитьСтроку(ПолноеИмяФайлаЛога, " " + Узел + " конец (" + СтрокаВозврата + ")");

		Исключение

			Ошибка = ОписаниеОшибки();

			СОД_Логирование.ДобавитьСтроку(ПолноеИмяФайлаЛога, " " + Узел + " конец: " + Ошибка);

		КонецПопытки;

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецПроцедуры

Процедура РегистрацииТочкаАктуальности_Запись(ДанныеПолучателя) Экспорт

	Если ДанныеПолучателя.Узел.ПротоколДоставкиОтправлений <> Перечисления.СОД_ПротоколыДоставкиОтправлений.AMQP Тогда
		Возврат;
	КонецЕсли;

	Узел = ДанныеПолучателя.Узел;

	ИмяОчереди = Узел.AMQPВходящееИмяТочкиОбмена + "." + Узел.AMQPВходящееИмяОчередиТочкаАктуальности;

	СОД_Обмен = СОД_Синхронизация.ПолучитьМодульСистемы();
	СОД_Обмен.Инициализировать(СОД_МаршрутизацияВызовСервераПовтИсп.ОбработкаОтладкиПравил());

	Попытка

		Клиент = СОД_Синхронизация.ПолучитьAMQPКлиентHTTP(Узел);

		Прочитано = Истина;

		Пока Прочитано Цикл
			
			// + начало получения сообщения

			HTTPЗапрос = Новый HTTPЗапрос;

			HTTPЗапрос.АдресРесурса = "/api/queues/" + Узел.AMQPВходящееВиртуальныйХост + "/" + ИмяОчереди + "/get";
			HTTPЗапрос.Заголовки.Вставить("Content-type", "application/json; charset=utf-8");

			Режим = ?(Истина, "ack_requeue_false", "ack_requeue_true");

			HTTPЗапрос.УстановитьТелоИзСтроки("{""count"":1,""ackmode"":""" + Режим
				+ """,""encoding"":""auto"",""truncate"":50000}");

			HTTPОтвет = Клиент.ОтправитьДляОбработки(HTTPЗапрос);

			Если HTTPОтвет.КодСостояния = 404 Тогда
				Прервать;
			ИначеЕсли HTTPОтвет.КодСостояния <> 200 Тогда
				ВызватьИсключение "Не удалось получить сообщение с сервера, код состояния: " + HTTPОтвет.КодСостояния;
			КонецЕсли;

			Сообщение = HTTPОтвет.ПолучитьТелоКакСтроку();

			Прочитано = Сообщение <> "[]";
			
			// - конец получения сообщения

			Если Не Прочитано Тогда
				Прервать;
			КонецЕсли;

			СообщениеAMQP = СОД_Синхронизация.ЗначениеИзСтроки(Сообщение, Перечисления.СОД_ФорматыСообщений.JSON)[0];

			СОД_Синхронизация.ДобавитьПротоколОбменаРегистрациями(Истина, СообщениеAMQP.payload);

			НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);

			СОД_Обмен.ЗаписатьСообщение(СообщениеAMQP.payload);

			ЗафиксироватьТранзакцию();

		КонецЦикла;

		Клиент = Неопределено;

		СОД_Обмен.МодульПравил = Неопределено;
		СОД_Обмен = Неопределено;

	Исключение

		СОД_Обмен.МодульПравил = Неопределено;
		СОД_Обмен = Неопределено;

		Ошибка = ОписаниеОшибки();

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецПроцедуры

Процедура РегистрацииОбработка() Экспорт
	
	// получим все необходимые данные для расчета и обработки
	// алгоритм расчитан для обработки регистраций на один конкретный узел
	// по правилам системы обмена, в оброботке могут учавствовать только регистрации, чья дата регистрации меньше точки актуальности по этому узлу
			
	// в качестве точки актуальности необходимо использовать наименьшую точку из двух баз

	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
				   |	Данные.Узел КАК Узел,
				   |	ВЫБОР
				   |		КОГДА Данные.ТочкаАктуальностиВходящая < Данные.ТочкаАктуальностиИсходящая
				   |			ТОГДА ЕСТЬNULL(Данные.ТочкаАктуальностиВходящая, ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0))
				   |		ИНАЧЕ ЕСТЬNULL(Данные.ТочкаАктуальностиИсходящая, ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0))
				   |	КОНЕЦ КАК ТочкаАктуальностиМинимальная,
				   |	Данные.ТочкаАктуальностиВходящая КАК ТочкаАктуальностиВходящая,
				   |	Данные.ТочкаАктуальностиИсходящая КАК ТочкаАктуальностиИсходящая
				   |ПОМЕСТИТЬ ТочкиАктуальности
				   |ИЗ
				   |	(ВЫБРАТЬ
				   |		ТочкиАктуальности.Узел КАК Узел,
				   |		МАКСИМУМ(ТочкиАктуальности.ТочкаАктуальностиВходящая) КАК ТочкаАктуальностиВходящая,
				   |		МАКСИМУМ(ТочкиАктуальности.ТочкаАктуальностиИсходящая) КАК ТочкаАктуальностиИсходящая
				   |	ИЗ
				   |		(ВЫБРАТЬ
				   |			СОД_ТочкиАктуальностиВходящие.Узел КАК Узел,
				   |			СОД_ТочкиАктуальностиВходящие.ТочкаАктуальности КАК ТочкаАктуальностиВходящая,
				   |			ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0) КАК ТочкаАктуальностиИсходящая
				   |		ИЗ
				   |			РегистрСведений.СОД_ТочкиАктуальностиВходящие КАК СОД_ТочкиАктуальностиВходящие
				   |		
				   |		ОБЪЕДИНИТЬ ВСЕ
				   |		
				   |		ВЫБРАТЬ
				   |			СОД_ТочкиАктуальностиИсходящие.Узел,
				   |			ДАТАВРЕМЯ(1, 1, 1, 0, 0, 0),
				   |			СОД_ТочкиАктуальностиИсходящие.ТочкаАктуальности
				   |		ИЗ
				   |			РегистрСведений.СОД_ТочкиАктуальностиИсходящие КАК СОД_ТочкиАктуальностиИсходящие) КАК ТочкиАктуальности
				   |	
				   |	СГРУППИРОВАТЬ ПО
				   |		ТочкиАктуальности.Узел) КАК Данные
				   |;
				   |
				   |////////////////////////////////////////////////////////////////////////////////
				   |ВЫБРАТЬ
				   |	СОД_Узлы.Ссылка КАК Узел,
				   |	ТочкиАктуальности.ТочкаАктуальностиМинимальная КАК ТочкаАктуальностиМинимальная
				   |ПОМЕСТИТЬ Узлы
				   |ИЗ
				   |	ПланОбмена.СОД_Узлы КАК СОД_Узлы
				   |		ЛЕВОЕ СОЕДИНЕНИЕ ТочкиАктуальности КАК ТочкиАктуальности
				   |		ПО СОД_Узлы.Ссылка = ТочкиАктуальности.Узел
				   |ГДЕ
				   |	СОД_Узлы.ПометкаУдаления = ЛОЖЬ
				   |
				   |ИНДЕКСИРОВАТЬ ПО
				   |	Узел,
				   |	ТочкиАктуальности.ТочкаАктуальностиМинимальная
				   |;
				   |
				   |////////////////////////////////////////////////////////////////////////////////
				   |ВЫБРАТЬ
				   |	Узлы.Узел КАК Узел,
				   |	СОД_Регистрации.Ссылка КАК Ссылка,
				   |	СОД_Регистрации.ГУИД КАК ГУИД,
				   |	СОД_Регистрации.Обработано КАК Обработано,
				   |	СОД_Регистрации.Направление КАК Направление
				   |ИЗ
				   |	Узлы КАК Узлы
				   |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.СОД_Регистрации КАК СОД_Регистрации
				   |		ПО Узлы.Узел = СОД_Регистрации.Узел
				   |			И Узлы.ТочкаАктуальностиМинимальная >= СОД_Регистрации.ДатаРегистрации
				   |ГДЕ
				   |	СОД_Регистрации.Обработано = ЛОЖЬ
				   |
				   |УПОРЯДОЧИТЬ ПО
				   |	Узел,
				   |	СОД_Регистрации.ДатаРегистрации,
				   |	СОД_Регистрации.Код";

	РезультатПакета = Запрос.ВыполнитьПакет();

	РезультатЗапроса = РезультатПакета[2].Выгрузить();

	РезультатПакета = Неопределено; // освободим память
	
	// разделим регистрации по узлам с сохранением порядка

	ДанныеПоПолучателям = Новый Массив;

	Для Каждого СтрокаЗапроса Из РезультатЗапроса Цикл

		ДанныеПолучателя = Неопределено;

		Для Каждого Данные Из ДанныеПоПолучателям Цикл

			Если Данные.Узел = СтрокаЗапроса.Узел Тогда

				ДанныеПолучателя = Данные;

				Прервать;

			КонецЕсли;

		КонецЦикла;

		Если ДанныеПолучателя = Неопределено Тогда

			ДанныеПолучателя = Новый Структура;
			ДанныеПолучателя.Вставить("Узел", СтрокаЗапроса.Узел);
			ДанныеПолучателя.Вставить("Метод", "Обработка");
			ДанныеПолучателя.Вставить("Строки", Новый ТаблицаЗначений);

			ДанныеПолучателя.Строки.Колонки.Добавить("Ссылка");
			ДанныеПолучателя.Строки.Колонки.Добавить("ГУИД");
			ДанныеПолучателя.Строки.Колонки.Добавить("Обработано");
			ДанныеПолучателя.Строки.Колонки.Добавить("Направление");

			ДанныеПоПолучателям.Добавить(ДанныеПолучателя);

		КонецЕсли;

		ЗаполнитьЗначенияСвойств(ДанныеПолучателя.Строки.Добавить(), СтрокаЗапроса);

	КонецЦикла;

	РезультатЗапроса = Неопределено; // освободим память

	Для Каждого ДанныеПолучателя Из ДанныеПоПолучателям Цикл

		Попытка

			ДанныеРегистраций = ДанныеПолучателя.Строки;
			
			// регистрации обрабатываем в хронологическом порядке, по дате регистрации

			Для Каждого СтрокаРегистрации Из ДанныеРегистраций Цикл
				
				// все транзакции по конкретному объекту обрабатывать смысла нет
				// по этому, нужно определить последнюю версию
				// если последняя версия сделана в этой базе - тогда просто отметим регистрации как обработанные
				// если последняя версия сделана в базе источнике - тогда запишем первую входящую и последнюю входящую версию (если это не одна и та же)

				РегистрацииКОбработке = ДанныеРегистраций.НайтиСтроки(Новый Структура("ГУИД,Обработано",
					СтрокаРегистрации.ГУИД, Ложь));

				КоличествоКОбработке = РегистрацииКОбработке.Количество();

				Если КоличествоКОбработке Тогда

					Если РегистрацииКОбработке[КоличествоКОбработке - 1].Направление
						= Перечисления.СОД_НаправлениеРегистрации.Исходящее Тогда
						
						// последняя версия сделана в этой базе
						// отметим регистрации как обработанные

						Для Номер = 0 По КоличествоКОбработке - 1 Цикл

							Ошибка = ОбработатьРегистрацию(РегистрацииКОбработке[Номер].Ссылка, Истина);

							Если ЗначениеЗаполнено(Ошибка) Тогда

								МодульПравил = Неопределено;

								ВызватьИсключение Ошибка;

							КонецЕсли;

							РегистрацииКОбработке[Номер].Обработано = Истина;

						КонецЦикла;

					Иначе
						
						// необходимо записать первую входящую версию регистрации и последнюю входящую, все остальные просто отметить как обработанные

						ПерваяОбработана 		= Ложь;
						ПоследняяРегистрация 	= РегистрацииКОбработке[КоличествоКОбработке - 1].Ссылка;

						Для Номер = 0 По КоличествоКОбработке - 1 Цикл

							ТекущаяРегистрация = РегистрацииКОбработке[Номер].Ссылка;

							Если ТекущаяРегистрация = ПоследняяРегистрация Тогда
								Обработано = Ложь; 		// это последняя регистрация, ее всегда нужно обработать
							ИначеЕсли ПерваяОбработана Тогда
								Обработано = Истина;	// если это не последняя регистрация, нужно проверить, может ранее была записана первая и все кроме последней будем не обробатывать ?
							Иначе	
								
								// если дошли сюда, значит это и не последняя и первую еще не обработали
								// поэтому определи, если входящая, значит эта та самая первая для обработки

								Обработано = Не (ТекущаяРегистрация.Направление
									= Перечисления.СОД_НаправлениеРегистрации.Входящее);
								
								// не забудем отметить, что первую мы обработали

								Если Не Обработано Тогда
									ПерваяОбработана = Истина;
								КонецЕсли;

							КонецЕсли;

							Ошибка = ОбработатьРегистрацию(РегистрацииКОбработке[Номер].Ссылка, Обработано);

							Если ЗначениеЗаполнено(Ошибка) Тогда

								МодульПравил = Неопределено;

								Текст = "Произошла ошибка при обработке регистрации: " + Символы.ПС
									+ "  Представление: " + РегистрацииКОбработке[Номер].Ссылка + Символы.ПС
									+ "  Код регистрации: " + РегистрацииКОбработке[Номер].Ссылка.Код + Символы.ПС
									+ "  Узел: " + РегистрацииКОбработке[Номер].Ссылка.Узел;

								СОД_Общий.СообщитьПользователю(Текст);

								ВызватьИсключение Ошибка;

							КонецЕсли;

							РегистрацииКОбработке[Номер].Обработано = Истина;

						КонецЦикла;

					КонецЕсли;

				КонецЕсли;

			КонецЦикла;

		Исключение

			МодульПравил = Неопределено; // уничтожим циклическую ссылку

			Ошибка = ОписаниеОшибки();

			ВызватьИсключение Ошибка;

		КонецПопытки;

		ДанныеПоПолучателям = Неопределено; // освободим память
        ПараметрыСеанса.СОД_ДанныеЗаписиОбъекта = Новый ФиксированнаяСтруктура("СОД_БезРегистрации", Ложь); // скинем параметр СОД_БезРегистрации

	КонецЦикла;

	МодульПравил = Неопределено; // уничтожим циклическую ссылку

КонецПроцедуры

Процедура РегистрацииУдаление(ГраницаУдаления, Количество) Экспорт

	Выборка = Справочники.СОД_Регистрации.Выбрать( , , , "Код Возр");

	ДатаГраницыУдаления				= УниверсальноеВремя( НачалоДня(ТекущаяДатаСеанса()) - ГраницаУдаления * 24 * 60
		* 60);
	КоличествоУдаляемыхРегистраций	= Количество;

	КоличествоУдаленныхРегистраций = 0;

	Пока Выборка.Следующий() Цикл

		Если КоличествоУдаленныхРегистраций = КоличествоУдаляемыхРегистраций Тогда
			Прервать;
		КонецЕсли;

		Если Выборка.ДатаРегистрации <= ДатаГраницыУдаления Тогда
			Если Не Выборка.ОбработкаПодтверждена Тогда
				Прервать;
			ИначеЕсли Выборка.ОбработкаПодтверждена Тогда
				КоличествоУдаленныхРегистраций = КоличествоУдаленныхРегистраций + 1;

				УдалениеОбъекта = Новый УдалениеОбъекта(Выборка.Ссылка);
				УдалениеОбъекта.Записать();
			КонецЕсли;
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

Процедура РегистрацииAMQP() Экспорт

	Попытка

		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ПротоколДоставкиОтправлений", Перечисления.СОД_ПротоколыДоставкиОтправлений.AMQP);
		Запрос.Текст = "ВЫБРАТЬ
					   |	СОД_Узлы.Ссылка КАК Узел
					   |ИЗ
					   |	ПланОбмена.СОД_Узлы КАК СОД_Узлы
					   |ГДЕ
					   |	СОД_Узлы.Узел = ИСТИНА
					   |	И СОД_Узлы.Отключен = ЛОЖЬ
					   |	И СОД_Узлы.ПротоколДоставкиОтправлений = &ПротоколДоставкиОтправлений";

		Узлы = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Узел");

		Для Каждого Узел Из Узлы Цикл

			ДанныеПолучателя = Новый Структура;
			ДанныеПолучателя.Вставить("Узел", Узел);

			РегистрацииТранспортПоток_Запись(ДанныеПолучателя);

			РегистрацииТочкаАктуальности_Запись(ДанныеПолучателя);

		КонецЦикла;

	Исключение

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		ВызватьИсключение Ошибка;

	КонецПопытки;

	МодульПравил = Неопределено;

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// ПЕРЕЧИСЛЕНИЯ: СОД

Функция Перечисление_СОД_ФорматыСообщений_Чтение(Ссылка) Экспорт
	
	// стандартные

	Возврат ПолучитьПолнуюСсылку(Ссылка);

КонецФункции

Функция Перечисление_СОД_ФорматыСообщений_Запись(ЭтаСтруктура) Экспорт

	Если Не ЗначениеЗаполнено(ЭтаСтруктура.Значение) Тогда
		ВызватьИсключение "Операция прервана ! Код обмена не может быть пустой !";
	КонецЕсли;

	УстановитьБезопасныйРежим(Истина);
	ЭтиДанные = Вычислить("Перечисления.СОД_ФорматыСообщений." + ЭтаСтруктура.Значение);
	УстановитьБезопасныйРежим(Ложь);

	Возврат ЭтиДанные;

КонецФункции

Функция Перечисление_СОД_НаправлениеРегистрации_Чтение(Ссылка) Экспорт
	
	// стандартные

	Возврат ПолучитьПолнуюСсылку(Ссылка);

КонецФункции

Функция Перечисление_СОД_НаправлениеРегистрации_Запись(ЭтаСтруктура) Экспорт

	Если Не ЗначениеЗаполнено(ЭтаСтруктура.Значение) Тогда
		ВызватьИсключение "Операция прервана ! Код обмена не может быть пустой !";
	КонецЕсли;

	УстановитьБезопасныйРежим(Истина);
	ЭтиДанные = Вычислить("Перечисления.СОД_НаправлениеРегистрации." + ЭтаСтруктура.Значение);
	УстановитьБезопасныйРежим(Ложь);

	Возврат ЭтиДанные;

КонецФункции

// СПРАВОЧНИКИ: СОД

Функция Справочник_СОД_Регистрации_Чтение(Ссылка, Ключи = Ложь, Метод = Неопределено) Экспорт

	ЭтаСтруктура = Новый Структура;
	
	// стандартные

	ЭтаСтруктура.Вставить("Ссылка", ПолучитьПолнуюСсылку(Ссылка));
	ЭтаСтруктура.Вставить("Наименование", Ссылка.Наименование);
	
	// метод

	ЭтаСтруктура.Ссылка.Вставить("Метод", Метод);
	
	// дополнительные простые

	ЭтаСтруктура.Вставить("ГУИД", Ссылка.ГУИД);
	ЭтаСтруктура.Вставить("Сеанс", Ссылка.Сеанс);
	ЭтаСтруктура.Вставить("Метаданные", Ссылка.Метаданные);
	ЭтаСтруктура.Вставить("ТекстовыеДанные", Ссылка.ТекстовыеДанные);
	ЭтаСтруктура.Вставить("УдалениеОбъекта", Ссылка.УдалениеОбъекта);
	ЭтаСтруктура.Вставить("МетаКод", Ссылка.МетаКод);
	ЭтаСтруктура.Вставить("ДатаРегистрации", Ссылка.ДатаРегистрации);
	ЭтаСтруктура.Вставить("Отправлено", Ссылка.Отправлено);
	ЭтаСтруктура.Вставить("Обработано", Ссылка.Обработано);
	ЭтаСтруктура.Вставить("ОбработкаПодтверждена", Ссылка.ОбработкаПодтверждена);
	ЭтаСтруктура.Вставить("ИсходящееПодтверждение", Ссылка.ИсходящееПодтверждение);
	ЭтаСтруктура.Вставить("ВходящееПодтверждение", Ссылка.ВходящееПодтверждение);
	
	// дополнительные сложные

	ЭтаСтруктура.Вставить("ДвоичныеДанные", "");
	ЭтаСтруктура.Вставить("Узел", ПланОбмена_СОД_Узлы_Чтение(Ссылка.Узел));
	ЭтаСтруктура.Вставить("ФорматСообщения", Перечисление_СОД_ФорматыСообщений_Чтение(Ссылка.ФорматСообщения));

	Возврат ЭтаСтруктура;

КонецФункции

Функция Справочник_СОД_Регистрации_Запись(ЭтаСтруктура) Экспорт

	Если Не ЗначениеЗаполнено(ЭтаСтруктура.Ссылка.ГУИД) Тогда
		ВызватьИсключение "Операция прервана ! Код обмена не может быть пустой !";
	КонецЕсли;

	Ссылка = Справочники.СОД_Регистрации.ПолучитьСсылку(Новый УникальныйИдентификатор(ЭтаСтруктура.Ссылка.ГУИД));

	ЭтиДанные = Ссылка.ПолучитьОбъект();

	Если ЭтиДанные = Неопределено Тогда
		ЭтиДанные = Справочники.СОД_Регистрации.СоздатьЭлемент();
		ЭтиДанные.УстановитьСсылкуНового(Ссылка);
	КонецЕсли;

	Если ЭтаСтруктура.Ссылка.Метод = "Транспорт" Тогда 
	
		// стандартные

		ЭтиДанные.Наименование 		= ЭтаСтруктура.Наименование;
		
		// дополнительные простые

		ЭтиДанные.ГУИД 	= ЭтаСтруктура.ГУИД;

		ЭтиДанные.Сеанс 			= ЭтаСтруктура.Сеанс;
		ЭтиДанные.Метаданные 		= ЭтаСтруктура.Метаданные;
		ЭтиДанные.ТекстовыеДанные 	= ЭтаСтруктура.ТекстовыеДанные;
		ЭтиДанные.УдалениеОбъекта 	= ЭтаСтруктура.УдалениеОбъекта;
		ЭтиДанные.МетаКод 			= ЭтаСтруктура.МетаКод;
		ЭтиДанные.ДатаРегистрации 	= ЭтаСтруктура.ДатаРегистрации;
		
		// дополнительные сложные

		ЭтиДанные.ДвоичныеДанные 	= ЭтаСтруктура.ДвоичныеДанные;
		ЭтиДанные.Узел				= ПланОбмена_СОД_Узлы_Запись(ЭтаСтруктура.Узел);
		ЭтиДанные.ФорматСообщения 	= Перечисление_СОД_ФорматыСообщений_Запись(ЭтаСтруктура.ФорматСообщения);

		Если ЭтиДанные.ФорматСообщения = Перечисления.СОД_ФорматыСообщений.ПустаяСсылка() Тогда
			ЭтиДанные.ФорматСообщения	= Перечисления.СОД_ФорматыСообщений.Native1C;
		КонецЕсли;

		ЭтиДанные.Направление		= Перечисления.СОД_НаправлениеРегистрации.Входящее;

		Если Не ЗначениеЗаполнено(ЭтиДанные.Узел) Тогда
			ВызватьИсключение "При записи входящей регистрации не удалось найти узел-отправитель. Операция транспорта регистрации прервана.";
		КонецЕсли;

	ИначеЕсли ЭтаСтруктура.Ссылка.Метод = "ТранспортПодтверждение" Тогда

		ЭтиДанные.ВходящееПодтверждение = Истина;

		Если ЭтиДанные.ИсходящееПодтверждение И ЭтиДанные.ВходящееПодтверждение Тогда
			ЭтиДанные.ОбработкаПодтверждена = Истина;
		КонецЕсли;

	Иначе

		ВызватьИсключение "При транспорте регистрации обнаружена ошибка. Метод не задан или задан не верно !";

	КонецЕсли;

	ЭтиДанные.Записать();

	Возврат ЭтиДанные.Ссылка;

КонецФункции

// ПЛАНЫ ОБМЕНА: СОД

Функция ПланОбмена_СОД_Узлы_Чтение(Ссылка) Экспорт

	ЭтаСтруктура = Новый Структура;
	
	// стандартные

	ЭтаСтруктура.Вставить("Ссылка", ПолучитьПолнуюСсылку(Ссылка));
	ЭтаСтруктура.Вставить("Код", СОД_СинхронизацияВызовСервераПовтИсп.ПолучитьКодУзла(Ссылка));

	Возврат ЭтаСтруктура;

КонецФункции

Функция ПланОбмена_СОД_Узлы_Запись(ЭтаСтруктура) Экспорт

	Если Не ЗначениеЗаполнено(ЭтаСтруктура.Ссылка.ГУИД) Тогда
		ВызватьИсключение "Операция прервана ! Код обмена не может быть пустой !";
	КонецЕсли;

	Возврат ПланыОбмена.СОД_Узлы.НайтиПоКоду(ЭтаСтруктура.Код);

КонецФункции

// РЕГИСТРЫ СВЕДЕНИЙ: СОД

Функция РегистрСведений_СОД_ТочкиАктуальностиИсходящие_Чтение(Набор) Экспорт

	ЭтаСтруктура = Новый Структура;

	ЭтаСтруктура.Вставить("Ссылка", ПолучитьПолнуюСсылку(Набор));
	ЭтаСтруктура.Вставить("Отбор", Новый Структура);
	ЭтаСтруктура.Вставить("Набор", Новый Массив);

	ЭтаСтруктура.Отбор.Вставить("Узел", ПланОбмена_СОД_Узлы_Чтение(Набор.Отбор.Узел.Значение));

	Для Каждого Запись Из Набор Цикл

		ЗаписьСтруктура = Новый Структура;
		ЗаписьСтруктура.Вставить("Узел", ПланОбмена_СОД_Узлы_Чтение(Запись.Узел));
		ЗаписьСтруктура.Вставить("ТочкаАктуальности", Запись.ТочкаАктуальности);

		ЭтаСтруктура.Набор.Добавить(ЗаписьСтруктура);

	КонецЦикла;

	Возврат ЭтаСтруктура;

КонецФункции

Процедура РегистрСведений_СОД_ТочкиАктуальностиВходящие_Запись(ЭтаСтруктура) Экспорт

	Узел = ПланОбмена_СОД_Узлы_Запись(ЭтаСтруктура.Отбор.Узел);

	Если Не ЗначениеЗаполнено(Узел) Тогда
		ВызватьИсключение "Ошибка получения точки актуальности. Узел не задан !";
	КонецЕсли;

	Если Не ЭтаСтруктура.Набор.Количество() Тогда
		ВызватьИсключение "Ошибка получения точки актуальности. Точка актуальности не задана или задвоена !";
	КонецЕсли;

	НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);

	БлокировкаДанных = Новый БлокировкаДанных;

	ЭлементБлокировки = БлокировкаДанных.Добавить("РегистрСведений.СОД_ТочкиАктуальностиВходящие");
	ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
	ЭлементБлокировки.УстановитьЗначение("Узел", Узел);

	Попытка

		БлокировкаДанных.Заблокировать();

	Исключение

		Ошибка = ОписаниеОшибки();

		ВызватьИсключение Ошибка;

	КонецПопытки;

	Набор = РегистрыСведений.СОД_ТочкиАктуальностиВходящие.СоздатьНаборЗаписей();
	Набор.Отбор.Узел.Установить(Узел);

	Для Каждого ЗаписьСтруктура Из ЭтаСтруктура.Набор Цикл

		Запись = Набор.Добавить();

		Запись.Узел 				= Узел;
		Запись.ТочкаАктуальности 	= ЗаписьСтруктура.ТочкаАктуальности;

	КонецЦикла;

	Набор.Записать();

	ЗафиксироватьТранзакцию();

КонецПроцедуры

// ПЛАТФОРМА

Функция Платформа_ВидСравнения_Запись(Значение) Экспорт

	Если ТипЗнч(Значение) = Тип("ВидСравнения") Тогда

		Возврат Значение;

	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда

		Если Значение = "Больше" Тогда
			ЗначениеСравнения	= ВидСравнения.Больше;
		ИначеЕсли Значение = "БольшеИлиРавно" Тогда
			ЗначениеСравнения	= ВидСравнения.БольшеИлиРавно;
		ИначеЕсли Значение = "ВИерархии" Тогда
			ЗначениеСравнения	= ВидСравнения.ВИерархии;
		ИначеЕсли Значение = "ВСписке" Тогда
			ЗначениеСравнения	= ВидСравнения.ВСписке;
		ИначеЕсли Значение = "ВСпискеПоИерархии" Тогда
			ЗначениеСравнения	= ВидСравнения.ВСпискеПоИерархии;
		ИначеЕсли Значение = "Интервал" Тогда
			ЗначениеСравнения	= ВидСравнения.Интервал;
		ИначеЕсли Значение = "ИнтервалВключаяГраницы" Тогда
			ЗначениеСравнения	= ВидСравнения.ИнтервалВключаяГраницы;
		ИначеЕсли Значение = "ИнтервалВключаяНачало" Тогда
			ЗначениеСравнения	= ВидСравнения.ИнтервалВключаяНачало;
		ИначеЕсли Значение = "ИнтервалВключаяОкончание" Тогда
			ЗначениеСравнения	= ВидСравнения.ИнтервалВключаяОкончание;
		ИначеЕсли Значение = "Меньше" Тогда
			ЗначениеСравнения	= ВидСравнения.Меньше;
		ИначеЕсли Значение = "МеньшеИлиРавно" Тогда
			ЗначениеСравнения	= ВидСравнения.МеньшеИлиРавно;
		ИначеЕсли Значение = "НеВИерархии" Тогда
			ЗначениеСравнения	= ВидСравнения.НеВИерархии;
		ИначеЕсли Значение = "НеВСписке" Тогда
			ЗначениеСравнения	= ВидСравнения.НеВСписке;
		ИначеЕсли Значение = "НеВСпискеПоИерархии" Тогда
			ЗначениеСравнения	= ВидСравнения.НеВСпискеПоИерархии;
		ИначеЕсли Значение = "НеРавно" Тогда
			ЗначениеСравнения	= ВидСравнения.НеРавно;
		ИначеЕсли Значение = "НеСодержит" Тогда
			ЗначениеСравнения	= ВидСравнения.НеСодержит;
		ИначеЕсли Значение = "Равно" Тогда
			ЗначениеСравнения	= ВидСравнения.Равно;
		ИначеЕсли Значение = "Содержит" Тогда
			ЗначениеСравнения	= ВидСравнения.Содержит;
		КонецЕсли;

		Возврат ЗначениеСравнения;

	КонецЕсли;

КонецФункции

// СЛУЖЕБНЫЕ

Функция РежимЗаписи(ЭтиДанные, ЭтаСтруктура) Экспорт

	Если ЭтиДанные.ЭтоНовый() Тогда

		Если ЭтаСтруктура.ПометкаУдаления Тогда
			РежимЗаписи = РежимЗаписиДокумента.Запись;
		ИначеЕсли Не ЭтаСтруктура.Проведен Тогда
			РежимЗаписи = РежимЗаписиДокумента.Запись;
		Иначе
			РежимЗаписи = РежимЗаписиДокумента.Проведение;
		КонецЕсли;

	Иначе

		Если ЭтаСтруктура.ПометкаУдаления И ЭтиДанные.Ссылка.Проведен Тогда

			РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения;

		ИначеЕсли Не ЭтаСтруктура.Проведен И ЭтиДанные.Ссылка.Проведен Тогда

			РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения;

		ИначеЕсли Не ЭтаСтруктура.Проведен Тогда

			РежимЗаписи = РежимЗаписиДокумента.Запись;

		Иначе

			РежимЗаписи = РежимЗаписиДокумента.Проведение;

		КонецЕсли;

	КонецЕсли;

	Возврат РежимЗаписи;

КонецФункции

Функция ЧтениеСоставногоТипа(ЭтиДанные) Экспорт

	Если НЕ ЗначениеЗаполнено(ЭтиДанные) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Ссылка = ПолучитьПолнуюСсылку(ЭтиДанные);

	Если Ссылка.Группа = "" Тогда

		Возврат Новый Структура("Ссылка", Ссылка);

	Иначе

		ИмяМетаданныхВИсточнике = Ссылка.Группа + "_" + Ссылка.Имя;
		
		Если СоответствиеМетаданных.Получить(ИмяМетаданныхВИсточнике) = Неопределено Тогда  //в модуле правил не предусмотрена выгрузка данного объекта
			Возврат Неопределено;
		КонецЕсли;

		УстановитьБезопасныйРежим(Истина);
		ЭтаСтруктура= Вычислить("МодульПравил." + ИмяМетаданныхВИсточнике + "_Чтение(ЭтиДанные, Истина)");
		УстановитьБезопасныйРежим(Ложь);

		Возврат ЭтаСтруктура;

	КонецЕсли;

КонецФункции

Функция ЗаписьСоставногоТипа(ЭтаСтруктура) Экспорт

	Если ЭтаСтруктура = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если ТипЗнч(ЭтаСтруктура) = Тип("Структура") Тогда

		Если ЭтаСтруктура.Свойство("Ссылка") Тогда
			Если ЭтаСтруктура.Ссылка.Группа = "" Тогда
				Возврат ЭтаСтруктура.Ссылка.Значение;
			Иначе 
				ИмяМетаданныхВИсточнике = ЭтаСтруктура.Ссылка.Группа + "_" + ЭтаСтруктура.Ссылка.Имя;
			КонецЕсли;
		Иначе
			ИмяМетаданныхВИсточнике = ЭтаСтруктура.Группа + "_" + ЭтаСтруктура.Имя;
		КонецЕсли;

		ИмяМетаданныхВПриемнике = СоответствиеМетаданных[ИмяМетаданныхВИсточнике];

		УстановитьБезопасныйРежим(Истина);
		ЭтиДанные = Вычислить(ИмяМетаданныхВПриемнике + "_Запись(ЭтаСтруктура, Истина)");
		УстановитьБезопасныйРежим(Ложь);

		Возврат ЭтиДанные;

	Иначе
		Возврат ЭтаСтруктура;
	КонецЕсли;

КонецФункции

Функция ПолучитьСсылку(Значение) Экспорт

	ПолнаяСсылка = Новый Структура;
	ПолнаяСсылка.Вставить("Группа", "");
	ПолнаяСсылка.Вставить("Имя", "");

	Если ТипЗнч(Значение) = Тип("Число") Тогда

		ПолнаяСсылка.Имя = "Число";

	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда

		ПолнаяСсылка.Имя = "Строка";

	ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда

		ПолнаяСсылка.Имя = "Булево";

	ИначеЕсли ТипЗнч(Значение) = Тип("Дата") Тогда

		ПолнаяСсылка.Имя = "Дата";

	Иначе

		ПолноеИмя = Значение.Метаданные().ПолноеИмя();

		Позиция = Найти(ПолноеИмя, ".");

		ПолнаяСсылка.Группа = Сред(ПолноеИмя, 1, Позиция - 1);
		ПолнаяСсылка.Имя 	= Сред(ПолноеИмя, Позиция + 1);

	КонецЕсли;

	Возврат ПолнаяСсылка;

КонецФункции

Функция ПолучитьПолнуюСсылку(Значение) Экспорт

	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	ПолнаяСсылка = ПолучитьСсылку(Значение);

	Если ПолнаяСсылка.Группа = "Перечисление" Тогда
		
		// для перечисления необходимо получить имя его значение как это заданно в конфигураторе

		Если ЗначениеЗаполнено(Значение) Тогда

			ИмяПеречисления 			= Значение.Метаданные().Имя;
			ИндексЗначенияПеречисления 	= Перечисления[ИмяПеречисления].Индекс(Значение);
			ИмяЗначенияПеречисления 	= Метаданные.Перечисления[ИмяПеречисления].ЗначенияПеречисления[ИндексЗначенияПеречисления].Имя;

		Иначе

			ИмяЗначенияПеречисления 	= "ПустаяСсылка()";

		КонецЕсли;

		ПолнаяСсылка.Вставить("Значение", ИмяЗначенияПеречисления);

	ИначеЕсли ПолнаяСсылка.Группа = "РегистрСведений" Тогда

		ОтборСтруктура = Новый Структура;

		Для Каждого Отбор Из Значение.Отбор Цикл

			ЗначениеОтбора = ПолучитьПолнуюСсылку(Отбор.Значение);

			ОтборСтруктура.Вставить(Отбор.Имя, Новый Структура("Использование, ВидСравнения, Значение",
				Отбор.Использование, Отбор.ВидСравнения, ЗначениеОтбора));

		КонецЦикла;

		ХешCRC32 = Новый ХешированиеДанных(ХешФункция.CRC32);
		ХешCRC32.Добавить(ЗначениеВСтрокуВнутр(ОтборСтруктура));

		Хеш1 = СтрЗаменить(ХешCRC32.ХешСумма, Символы.НПП, "");

		ХешCRC32 = Новый ХешированиеДанных(ХешФункция.CRC32);
		ХешCRC32.Добавить(ПолнаяСсылка.Имя);

		Хеш2 = СтрЗаменить(ХешCRC32.ХешСумма, Символы.НПП, "");

		ПолнаяСсылка.Вставить("ГУИД", Хеш2 + Хеш1);

	ИначеЕсли ПолнаяСсылка.Группа = "" Тогда	
		
		// простые типы данных

		ПолнаяСсылка.Вставить("Значение", Значение);

	Иначе
		
		// для объектно-ссылочных типов

		Если Значение = Значение.Ссылка Тогда
			
			// Если это ссылка

			ПолнаяСсылка.Вставить("ГУИД", Строка(Значение.УникальныйИдентификатор()));

		Иначе
			
			// Если это объект

			ПолнаяСсылка.Вставить("ГУИД", Строка(Значение.Ссылка.УникальныйИдентификатор()));

		КонецЕсли;

	КонецЕсли;

	Возврат ПолнаяСсылка;

КонецФункции

Процедура ЗаполнитьУниверсальнуюСтруктуру(Источник, ЭтаСтруктура) Экспорт

	МетаданныеОбъекта = Источник.Метаданные();

	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		
		Если Реквизит.Имя = "Предопределенный" Тогда
			Продолжить;
		ИначеЕсли Реквизит.Имя = "Ссылка" Тогда
			ЭтаСтруктура.Вставить(Реквизит.Имя, ПолучитьПолнуюСсылку(Источник[Реквизит.Имя]));
		Иначе
			
			Если НЕ ЗначениеЗаполнено(Источник[Реквизит.Имя]) Тогда
				
				ЭтаСтруктура.Вставить(Реквизит.Имя, Неопределено);
				Продолжить;
				
			КонецЕсли;
				
			СтруктураРеквизита = ЧтениеСоставногоТипа(Источник[Реквизит.Имя]);
			
			Если СтруктураРеквизита.Ссылка.Группа = "" Тогда
				ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита.Ссылка.Значение);
			ИначеЕсли СтруктураРеквизита.Ссылка.Группа = "Перечисление" Тогда
				ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита.Ссылка);
			Иначе
				ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита);
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;

	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл

		Если Не ЗначениеЗаполнено(Источник[Реквизит.Имя]) Тогда

			ЭтаСтруктура.Вставить(Реквизит.Имя, Неопределено);
			Продолжить;

		КонецЕсли;

		СтруктураРеквизита = ЧтениеСоставногоТипа(Источник[Реквизит.Имя]);

		Если СтруктураРеквизита.Ссылка.Группа = "" Тогда
			ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита.Ссылка.Значение);
		ИначеЕсли СтруктураРеквизита.Ссылка.Группа = "Перечисление" Тогда
			ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита.Ссылка);	
		Иначе
			ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита);
		КонецЕсли;

	КонецЦикла;

	Если Не ЗначениеЗаполнено(МетаданныеОбъекта.ТабличныеЧасти) 
	        Или МетаданныеОбъекта.ТабличныеЧасти.Количество() = 0 Тогда
		Возврат;

	КонецЕсли;

	Для Каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл

		МассивТабличнаяЧасть = Новый Массив;

		Для Каждого Строка Из Источник[ТабличнаяЧасть.Имя] Цикл

			СтруктураДанных = Новый Структура;

			Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл

				Если Не ЗначениеЗаполнено(Строка[Реквизит.Имя]) Тогда

					СтруктураДанных.Вставить(Реквизит.Имя, Неопределено);
					Продолжить;

				КонецЕсли;

				СтруктураРеквизита = ЧтениеСоставногоТипа(Строка[Реквизит.Имя]);

				Если СтруктураРеквизита.Ссылка.Группа = "" Тогда
					СтруктураДанных.Вставить(Реквизит.Имя, СтруктураРеквизита.Ссылка.Значение);
				ИначеЕсли СтруктураРеквизита.Ссылка.Группа = "Перечисление" Тогда
					ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита.Ссылка);
				Иначе
					СтруктураДанных.Вставить(Реквизит.Имя, СтруктураРеквизита);
				КонецЕсли;

			КонецЦикла;

			МассивТабличнаяЧасть.Добавить(СтруктураДанных);

		КонецЦикла;

		ЭтаСтруктура.Вставить(ТабличнаяЧасть.Имя, МассивТабличнаяЧасть);

	КонецЦикла;

КонецПроцедуры

Процедура ПрочитатьУниверсальнуюСтруктуру(Источник, ЭтаСтруктура) Экспорт

	МетаданныеОбъекта = Источник.Метаданные();

	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		Если Реквизит.Имя = "Предопределенный" Или Реквизит.Имя = "Ссылка" Или Реквизит.Имя = "ЭтоГруппа"
			Или Не ЗначениеЗаполнено(ЭтаСтруктура[Реквизит.Имя]) Тогда
			Продолжить;
		Иначе
			Источник[Реквизит.Имя] = ЗаписьСоставногоТипа(ЭтаСтруктура[Реквизит.Имя]);
		КонецЕсли;
	КонецЦикла;

	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		
		Если НЕ ЗначениеЗаполнено(ЭтаСтруктура[Реквизит.Имя]) Тогда
			Продолжить;
		КонецЕсли;
			
		Источник[Реквизит.Имя] = ЗаписьСоставногоТипа(ЭтаСтруктура[Реквизит.Имя]);
	
	КонецЦикла;

	Если Не ЗначениеЗаполнено(МетаданныеОбъекта.ТабличныеЧасти) Или МетаданныеОбъекта.ТабличныеЧасти.Количество() = 0 Тогда

		Возврат;

	КонецЕсли;

	Для Каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
		
		Источник[ТабличнаяЧасть.Имя].Очистить();
		
		Для Каждого Строка Из ЭтаСтруктура[ТабличнаяЧасть.Имя] Цикл

			НоваяСтрока = Источник[ТабличнаяЧасть.Имя].Добавить();

			Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл

				Если Не ЗначениеЗаполнено(Строка[Реквизит.Имя]) Тогда
					Продолжить;
				КонецЕсли;

				НоваяСтрока[Реквизит.Имя] = ЗаписьСоставногоТипа(Строка[Реквизит.Имя]);

			КонецЦикла;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

Функция ОбработатьРегистрацию(Регистрация, Обработано = Ложь) Экспорт
	
	// обработка данных объекта и самой транзакции должно быть атомарным

	НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);

	РегистрацияОбъект = Регистрация.ПолучитьОбъект();

	Попытка
		
		// возможно другой поток работает с этой регистрацией, проверим

		РегистрацияОбъект.Заблокировать();

	Исключение
		
		// если другой поток занял регистрацию, просто прервем обработку

		Ошибка = ОписаниеОшибки();

		МодульПравил = Неопределено;

		Возврат Ошибка;

	КонецПопытки;

	Попытка
		
		// если флаг Обработано возведен, значит нужно просто пометить регистрацию как обработанную без фактической обработки данных объекта в регистрации

		Если Не Обработано Тогда

			Если Не ЗначениеЗаполнено(Регистрация.ФорматСообщения) Тогда
				ВызватьИсключение "Пояснение СОД: обработка невозможна так как формат сообщения не указан в регистрации.";
			КонецЕсли;

			СтруктураОбъекта = СОД_Синхронизация.ЗначениеИзСтроки(РегистрацияОбъект.ТекстовыеДанные,
				Регистрация.ФорматСообщения).ТекстовыеДанные;
				
			ПараметрыСеанса.СОД_ДанныеЗаписиОбъекта = Новый ФиксированнаяСтруктура("СОД_БезРегистрации", Ложь);	
				
			ИмяМетаданныхВИсточнике = СтруктураОбъекта.Ссылка.Группа + "_" + СтруктураОбъекта.Ссылка.Имя;
			ИмяМетаданныхВПриемнике = СоответствиеМетаданных[ИмяМетаданныхВИсточнике];

			ИмяМетодаПравила = ИмяМетаданныхВПриемнике + "_Запись(СтруктураОбъекта, , Регистрация)";

			УстановитьБезопасныйРежим(Истина);
			Выполнить (ИмяМетодаПравила);
			УстановитьБезопасныйРежим(Ложь);

		КонецЕсли;

		РегистрацияОбъект.Обработано = Истина;

		РегистрацияОбъект.Записать();

		ЗафиксироватьТранзакцию();

	Исключение

		Ошибка = ОписаниеОшибки();

		Попытка

			РегистрацияОбъект.Обработано = Ложь;

			РегистрацияОбъект.Ошибка = Истина;
			РегистрацияОбъект.ОписаниеОшибки = Ошибка;

			РегистрацияОбъект.Записать();

			ЗафиксироватьТранзакцию();

		Исключение

			ОтменитьТранзакцию();

		КонецПопытки;

		МодульПравил = Неопределено;

		Возврат Ошибка;

	КонецПопытки;

	Возврат "";

КонецФункции

Процедура УниверсальнаяСтруктураИзОбъекта_Чтение(Источник, ЭтаСтруктура) Экспорт

	МетаданныеОбъекта = Источник.Метаданные();

	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		
		Если Реквизит.Имя = "Предопределенный" ИЛИ Реквизит.Имя = "Ссылка" Тогда
			Продолжить;
		Иначе
			
			Если НЕ ЗначениеЗаполнено(Источник[Реквизит.Имя]) Тогда
				
				ЭтаСтруктура.Вставить(Реквизит.Имя, Неопределено);
				Продолжить;
				
			КонецЕсли;
				
			СтруктураРеквизита = ЧтениеСоставногоТипа(Источник[Реквизит.Имя]);
			
			Если СтруктураРеквизита.Свойство("Ссылка") Тогда
				Если СтруктураРеквизита.Ссылка.Группа = "" Тогда
					ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита.Ссылка.Значение);
				Иначе
					ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита);
				КонецЕсли;
			Иначе
				ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита);
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;

	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл

		Если Не ЗначениеЗаполнено(Источник[Реквизит.Имя]) Тогда

			ЭтаСтруктура.Вставить(Реквизит.Имя, Неопределено);
			Продолжить;

		КонецЕсли;

		СтруктураРеквизита = ЧтениеСоставногоТипа(Источник[Реквизит.Имя]);
		
		Если СтруктураРеквизита = Неопределено Тогда

			ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита);
			Продолжить;

		КонецЕсли;

		Если СтруктураРеквизита.Свойство("Ссылка") Тогда
			Если СтруктураРеквизита.Ссылка.Группа = "" Тогда
				ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита.Ссылка.Значение);
			Иначе
				ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита);
			КонецЕсли;
		Иначе
			ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита);	
		КонецЕсли;	
	КонецЦикла;

	Если Не ЗначениеЗаполнено(МетаданныеОбъекта.ТабличныеЧасти) 
	        Или МетаданныеОбъекта.ТабличныеЧасти.Количество() = 0 Тогда
		Возврат;

	КонецЕсли;

	Для Каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл

		МассивТабличнаяЧасть = Новый Массив;

		Для Каждого Строка Из Источник[ТабличнаяЧасть.Имя] Цикл
			
			СтруктураДанных = Новый Структура;
			
			Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
				
				Если Не ЗначениеЗаполнено(Строка[Реквизит.Имя]) Тогда
					
					СтруктураДанных.Вставить(Реквизит.Имя, Неопределено);
					Продолжить;
					
				КонецЕсли;
				
				СтруктураРеквизита = ЧтениеСоставногоТипа(Строка[Реквизит.Имя]);
				
				Если СтруктураРеквизита = Неопределено Тогда
					
					ЭтаСтруктура.Вставить(Реквизит.Имя, СтруктураРеквизита);
					Продолжить;
					
				КонецЕсли;
				
				Если СтруктураРеквизита.Свойство("Ссылка") Тогда
					Если СтруктураРеквизита.Ссылка.Группа = "" Тогда
						СтруктураДанных.Вставить(Реквизит.Имя, СтруктураРеквизита.Ссылка.Значение);
					Иначе
						СтруктураДанных.Вставить(Реквизит.Имя, СтруктураРеквизита);
					КонецЕсли;
				Иначе
					СтруктураДанных.Вставить(Реквизит.Имя, СтруктураРеквизита);
				КонецЕсли;	
			КонецЦикла;

			МассивТабличнаяЧасть.Добавить(СтруктураДанных);

		КонецЦикла;

		ЭтаСтруктура.Вставить(ТабличнаяЧасть.Имя, МассивТабличнаяЧасть);

	КонецЦикла;

КонецПроцедуры

Процедура ОбъектИзУниверсальнойСтруктуры_Запись(Источник, ЭтаСтруктура) Экспорт

	МетаданныеОбъекта = Источник.Метаданные();

	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		Если Реквизит.Имя = "Предопределенный" Или Реквизит.Имя = "Ссылка" Или Реквизит.Имя = "ЭтоГруппа" Или Реквизит.Имя = "Код"
			Или Не ЗначениеЗаполнено(ЭтаСтруктура[Реквизит.Имя]) Тогда
			Продолжить;
		Иначе
			Источник[Реквизит.Имя] = ЗаписьСоставногоТипа(ЭтаСтруктура[Реквизит.Имя]);
		КонецЕсли;
	КонецЦикла;

	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		
		Если НЕ ЗначениеЗаполнено(ЭтаСтруктура[Реквизит.Имя]) Тогда
			Продолжить;
		КонецЕсли;
			
		Источник[Реквизит.Имя] = ЗаписьСоставногоТипа(ЭтаСтруктура[Реквизит.Имя]);
	
	КонецЦикла;

	Если Не ЗначениеЗаполнено(МетаданныеОбъекта.ТабличныеЧасти) Или МетаданныеОбъекта.ТабличныеЧасти.Количество() = 0 Тогда

		Возврат;

	КонецЕсли;

	Для Каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
		
		Если Источник[ТабличнаяЧасть.Имя].Количество() > 0 Тогда
			Для Каждого Строка Из Источник[ТабличнаяЧасть.Имя] Цикл
				Источник[ТабличнаяЧасть.Имя].Удалить(Строка);
			КонецЦикла;	
		КонецЕсли;	
		
		Для Каждого Строка Из ЭтаСтруктура[ТабличнаяЧасть.Имя] Цикл

			НоваяСтрока = Источник[ТабличнаяЧасть.Имя].Добавить();

			Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл

				Если Не ЗначениеЗаполнено(Строка[Реквизит.Имя]) Тогда
					Продолжить;
				КонецЕсли;

				НоваяСтрока[Реквизит.Имя] = ЗаписьСоставногоТипа(Строка[Реквизит.Имя]);

			КонецЦикла;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область Инициализация

СоответствиеМетаданных = Новый Соответствие;

СоответствиеМетаданных["Справочник_СОД_Регистрации"] 						= "ЭтотОбъект.Справочник_СОД_Регистрации";
СоответствиеМетаданных["РегистрСведений_СОД_ТочкиАктуальностиИсходящие"] 	= "ЭтотОбъект.РегистрСведений_СОД_ТочкиАктуальностиВходящие";

СоответствиеРегистраций = Новый Соответствие;

#КонецОбласти

#КонецЕсли